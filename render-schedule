#!/usr/bin/env python3.14

import json 
import argparse
from colorama import Fore, Style, init
from datetime import datetime, timedelta


schedule = None
overrides = None


#parser =  argparse.ArgumentParser()
#parser.add_argument('--schedule',  required=True, help='Path to the schedule JSON file')
#parser.add_argument('--overrides', required=True, help='Path to the overrides JSON file')
#parser.add_argument('--from', dest= 'from_time', required=True, help='Start time (ISO format)')
#parser.add_argument('--until', dest= 'until_time', required=True, help='End time (ISO format)')
#args = parser.parse_args()

#from_time = datetime.fromisoformat(parser.parse_args().from_time.replace('Z', '+00:00'))
#until_time = datetime.fromisoformat(parser.parse_args().until_time.replace('Z', '+00:00'))


with open('schedule.json', 'r') as f:
    schedule = json.load(f)
with open('overrides.json', 'r') as f:
    overrides = json.load(f)


class ScheduleEntry:
    def __init__(self, user, start_at, end_at,override=False):
        self.user = user
        self.start_at = start_at
        self.end_at = end_at
        self.override = override

    def __str__(self):
        return f"{self.user}, Start: {self.start_at.strftime('%b %d %H:%M')}, End: {self.end_at.strftime('%b %d %H:%M')}"
    
    def set_start(self, start_at):
        self.start_at = start_at

    def set_end(self, end_at):
        self.end_at = end_at
   
    def setEntry(self, user, start_at, end_at):
        self.user = user
        self.start_at = start_at
        self.end_at = end_at

    def dict(self):
        return {
            'user': self.user,
            'start_at': self.start_at.strftime('%d %B %H:%M'),
            #self.start_at.isoformat().replace('+00:00', 'Z'),
            'end_at': self.end_at.strftime('%d %B %H:%M')
            #self.start_at.isoformat().replace('+00:00', 'Z'),
        }

def general_schedule():

    users = schedule['users']
    handover_start_at = datetime.fromisoformat(schedule['handover_start_at'].replace('Z', '+00:00'))
    handover_interval_days = schedule['handover_interval_days']
    base_schedule = []


    for i in range(len(users)): 
        user = users[i % len(users)]
        start_at = handover_start_at + timedelta(days=i * handover_interval_days)
        end_at = start_at + timedelta(days=handover_interval_days)
        entry = ScheduleEntry(user, start_at, end_at, override=False)
        base_schedule.append(entry)

    return base_schedule

def override_schedule(schedule):
    
    for o in overrides:
        override_user = o['user']
        override_start_at = datetime.fromisoformat(o['start_at'].replace('Z', '+00:00'))
        override_end_at = datetime.fromisoformat(o['end_at'].replace('Z', '+00:00'))
        override_entry = ScheduleEntry(override_user, override_start_at, override_end_at, override=True)
        schedule.append(override_entry) 
    return schedule

def overlap(schedule):

    fixed_schedule = []
    skip_next = False

    for i, entry in enumerate(schedule):


        if skip_next:
            skip_next = False
            continue

        current_entry = schedule[i]

        if i+1 < len(schedule):
            
            next_entry = schedule[i+1]

            if current_entry.end_at > next_entry.start_at:

                fixed_schedule.append(current_entry)
                fixed_schedule.append(next_entry)
                new_entry = ScheduleEntry(
                    user=entry.user,
                    start_at=next_entry.end_at,
                    end_at=current_entry.end_at,
                    override=False
                )
                fixed_schedule.append(new_entry)
                skip_next = True
            
            else:
                fixed_schedule.append(current_entry)
        else:
            fixed_schedule.append(current_entry)

    return fixed_schedule

def truncate(schedule, start_time, end_time):

    for i, entry in enumerate(schedule):

        start = entry.start_at
        end = entry.end_at

        if i == len(schedule)-1 and end > end_time:
            entry.set_end(end_time)

        if i== 0 and start < start_time:
            entry.set_start(start_time)

        if start < start_time and end > start_time:
            entry.set_start(start_time)
        if start < end_time and end > end_time:
            entry.set_end(end_time)

        if i+1 < len(schedule):
            next_entry = schedule[i+1]
            if end > next_entry.start_at:
                entry.set_end(next_entry.start_at)
                
        if i> 0:
            prev_entry = schedule[i-1]
            if entry.start_at > prev_entry.end_at:
                entry.set_start(prev_entry.end_at)



    return schedule

def get_time(entered_time):

    try:
        time = input(entered_time).strip()
        formatted_time = datetime.fromisoformat(time.replace('Z', '+00:00'))
        return formatted_time
    except ValueError:
        print("Invalid time format. Please enter time in ISO format (e.g., 2024-07-01T00:00:00Z). \n")
        return get_time(entered_time)

start_time = get_time("When would you like the schedule to start? (ISO format, e.g., 2025-01-01T00:00:00Z)\n")
end_time = get_time("When would you like the schedule to end? (ISO format, e.g., 2025-12-31T23:59:59Z)\n")

base_schedule = general_schedule()
full_schedule = override_schedule(base_schedule)
full_schedule.sort(key=lambda entry: entry.start_at)
full_schedule = overlap(full_schedule)
final_schedule = truncate(full_schedule, start_time, end_time)


for entry in final_schedule:
    if entry.override == True:
        print(Fore.BLUE+ str(entry.dict()) + Style.RESET_ALL)
    else:
        print(entry.dict())
