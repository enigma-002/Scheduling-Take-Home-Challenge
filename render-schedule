#!/usr/bin/env python3.14

"""
Schedule Renderer which creates a handover schedule based on number of user and takes into account overrides.
"""

import json 
import argparse
from datetime import datetime, timedelta

def parse_arguments():
    parser =  argparse.ArgumentParser()
    parser.add_argument('--schedule', help='Schedule JSON file', required=True)
    parser.add_argument('--overrides',help='Override JSON file', required=True,)
    parser.add_argument('--from', dest= 'from_time', required=True,)
    parser.add_argument('--until', dest= 'until_time', required=True,)
    return parser.parse_args()

class ScheduleEntry:
    
    """lass to represent a single schedule entry."""
    def __init__(self, user, start_at, end_at,override=False):
        self.user = user
        self.start_at = start_at
        self.end_at = end_at
        self.override = override

    def set_start(self, start_at):
        self.start_at = start_at

    def set_end(self, end_at):
        self.end_at = end_at

    def dict(self):
        return {
            'user': self.user,
            'start_at': self.start_at.isoformat().replace('+00:00', 'Z'),
            'end_at': self.end_at.isoformat().replace('+00:00', 'Z'),
  
        }
    def __str__(self):
        return f"{self.user}, Start: {self.start_at.strftime('%b %d %H:%M')}, End: {self.end_at.strftime('%b %d %H:%M')}"
    
def general_schedule(schedule):
    """Generates the general schedule based on users and handover intervals."""

    users = schedule['users']
    start_at = datetime.fromisoformat(schedule['handover_start_at'].replace('Z', '+00:00'))
    interval_days = schedule['handover_interval_days']
    base_schedule = []

    for i in range(len(users)):
        user = users[i % len(users)]
        entry_start = start_at + timedelta(days=i * interval_days)
        entry_end = entry_start + timedelta(days=interval_days)
        entry = ScheduleEntry(user, entry_start, entry_end, override=False)
        base_schedule.append(entry)

    return base_schedule

def override_schedule(schedule,overrides):
    """Adds overrides to the base schedule."""
    for o in overrides:
        override_user = o['user']
        override_start_at = datetime.fromisoformat(o['start_at'].replace('Z', '+00:00'))
        override_end_at = datetime.fromisoformat(o['end_at'].replace('Z', '+00:00'))

        override_entry = ScheduleEntry(override_user, override_start_at, override_end_at, override=True)
        schedule.append(override_entry) 
    return schedule

def overlap_fix(schedule):
    """Fixes overlapping schedule times by trimming a replacing times and then adds new entries as needed."""

    schedule.sort(key=lambda entry: entry.start_at) #sorts by start time

    fixed_schedule = []

    for entry in schedule:
        if not fixed_schedule:
            fixed_schedule.append(entry)
            continue
            
        current_entry = fixed_schedule[-1]

        if entry.start_at >= current_entry.end_at: 
            fixed_schedule.append(entry)

        if entry.end_at <= current_entry.end_at: #case where the current entry does not finish before the new one starts
            previous_end = current_entry.end_at #save time to ensure that everyone does the interval amount of dasys
            current_entry.end_at = entry.start_at #fix end time 
            fixed_schedule.append(entry)

        if entry.end_at < previous_end: #add new entry for remaining time so everyone does their interval
            fixed_schedule.append(ScheduleEntry(current_entry.user, entry.end_at, previous_end, override=current_entry.override))

    return fixed_schedule


def truncate(schedule, start_time, end_time):
    """Truncates schedule to fit within specified time range."""
    for i, entry in enumerate(schedule):

        start = entry.start_at
        end = entry.end_at

        if i == len(schedule)-1 and end > end_time:
            entry.set_end(end_time)

        if i== 0 and start < start_time:
            entry.set_start(start_time)

        if start < start_time and end > start_time:
            entry.set_start(start_time)
        if start < end_time and end > end_time:
            entry.set_end(end_time)

        if i+1 < len(schedule):
            next_entry = schedule[i+1]
            if end > next_entry.start_at:
                entry.set_end(next_entry.start_at)
                
        if i> 0:
            prev_entry = schedule[i-1]
            if entry.start_at > prev_entry.end_at:
                entry.set_start(prev_entry.end_at)
    return schedule

def main():
    args = parse_arguments()

    with open(args.schedule, 'r') as f:
        schedule = json.load(f)
    with open(args.overrides, 'r') as f:
        overrides = json.load(f)


    start_time = datetime.fromisoformat(args.from_time.replace('Z', '+00:00'))
    end_time = datetime.fromisoformat(args.until_time.replace('Z', '+00:00'))

    base_schedule = general_schedule(schedule)
    full_schedule = override_schedule(base_schedule,overrides)
    fixed_schedule = overlap_fix(full_schedule)
    final_schedule = truncate(fixed_schedule, start_time, end_time)


    output =[entry.dict() for entry in final_schedule]
    print(json.dumps(output, indent=2))

if __name__ == "__main__":
    main()